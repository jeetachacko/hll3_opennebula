'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Factory method for creation random distributed methods
 * Created by Alexey S. Kiselev
 */

var RandomFactory = function () {
    function RandomFactory() {
        _classCallCheck(this, RandomFactory);

        this._distributions = {};
    }

    /**
     * Sets current generator
     */


    _createClass(RandomFactory, [{
        key: 'set_current_generator',
        value: function set_current_generator(method) {
            var _current_method;

            var _method = method.slice(0, -3);

            for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                params[_key - 1] = arguments[_key];
            }

            if (!this._distributions[_method]) {
                var Method = require(__dirname + '/methods/' + method);
                this._distributions[_method] = new (Function.prototype.bind.apply(Method, [null].concat(_toConsumableArray(params))))();
            }

            this._current_method = this._distributions[_method];
            (_current_method = this._current_method).refresh.apply(_current_method, _toConsumableArray(params));
        }

        /**
         * Required method
         * Method .random(): Promise<number> generates a random number due to distribution
         * This method is asynchronous, contains method .then(data: number => {}) and
         * .catch(err: {error: string} => {}) corresponds to error in random distribution
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns a random number on each call, can be integer or float
         */

    }, {
        key: 'random',
        value: function random() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    if (_this.isError().error) {
                        reject(_this.isError());
                    } else {
                        resolve(_this._current_method.random());
                    }
                }, 0);
            });
        }

        /**
         * Required method
         * Method .next(): Promise<number> generates a next seeded random number due to distribution
         * This method is asynchronous, contains method .then(data: number => {}) and
         * .catch(err: {error: string} => {}) corresponds to error in random distribution
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns a random number on each call, can be integer or float
         */

    }, {
        key: 'next',
        value: function next() {
            var _this2 = this;

            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    if (_this2.isError().error) {
                        reject(_this2.isError());
                    } else {
                        resolve(_this2._current_method.next());
                    }
                }, 0);
            });
        }

        /**
         * Required method
         * Method .randomSync(): number generates a random number due to distribution
         * This method is synchronous
         * Produces a random number or throw an error message
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns a random number on each call, can be integer or float
         */

    }, {
        key: 'randomSync',
        value: function randomSync() {
            if (this.isError().error) {
                throw new Error(this.isError().error);
            } else return this._current_method.random();
        }

        /**
         * Required method
         * Method .nextSync(): number generates a seeded next random number due to distribution
         * This method is synchronous
         * Produces a random number or throw an error message
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns a random number on each call, can be integer or float
         */

    }, {
        key: 'nextSync',
        value: function nextSync() {
            if (this.isError().error) {
                throw new Error(this.isError().error);
            } else return this._current_method.next();
        }

        /**
         * Required method
         * Method .distribution(n: number): Promise<Array<number>> generates an array of random numbers due to distribution
         * Contains n (n > 0) random distributed numbers. By default n = 10
         * Can contains additional parameters for formatting purposes
         * This method is asynchronous, contains method .then(data: Array<number> => {}) and
         * .catch(err: {error: string} => {}) corresponds to error in random distribution
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns an array of random numbers on each call, numbers can be integer or float
         */

    }, {
        key: 'distribution',
        value: function distribution() {
            var _this3 = this;

            for (var _len2 = arguments.length, distParams = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                distParams[_key2 - 1] = arguments[_key2];
            }

            var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

            if (n < 1) {
                n = 1;
            }
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    if (_this3.isError().error) {
                        reject(_this3.isError());
                    } else {
                        var _current_method2;

                        resolve((_current_method2 = _this3._current_method).distribution.apply(_current_method2, [n].concat(_toConsumableArray(distParams))));
                    }
                }, 0);
            });
        }

        /**
         * Required method
         * Method .distributionSync(n: number): Array<number> generates an array of random numbers due to distribution
         * Contains n (n > 0) random distributed numbers. By default n = 10
         * Can contains additional parameters for formatting purposes
         * This method is synchronous. Produces an array of random numbers or throw an error message
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns an array of random numbers on each call, numbers can be integer or float
         */

    }, {
        key: 'distributionSync',
        value: function distributionSync() {
            var _current_method3;

            var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

            if (n < 1) {
                n = 1;
            }

            for (var _len3 = arguments.length, distParams = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                distParams[_key3 - 1] = arguments[_key3];
            }

            if (this.isError().error) {
                throw new Error(this.isError().error);
            } else return (_current_method3 = this._current_method).distribution.apply(_current_method3, [n].concat(_toConsumableArray(distParams)));
        }

        /**
         * Required method
         * Method .isError(): boolean | {error: string} checks whether an error occurs in random method due to incorrect input values
         * This method is synchronous.
         * @returns "false" if no error occurred
         * or {error: string} object with error message if error occurred
         */

    }, {
        key: 'isError',
        value: function isError() {
            return this._current_method.isError();
        }

        /**
         * Required method
         * Method .refresh(..params): void change th input values in existing distribution without creating new instance
         * Input parameters must be the same as in constructor
         * In this method .isError will refreshes too
         * Examle usage:
         * let normal = randomjs.normal(1, 2);
         * normal.random() // will generate random numbers with Gaussian distribution with mu = 1 and sigma = 2
         * normal.refresh(3, 4);
         * normal.random() // will generate random numbers with Gaussian distribution with mu = 3 and sigma = 4
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            var _current_method4;

            (_current_method4 = this._current_method).refresh.apply(_current_method4, arguments);
        }

        /**
         * class .toString() method, which will output information about distribution
         * @returns string
         */

    }, {
        key: 'toString',
        value: function toString() {
            return this._current_method.toString();
        }
    }]);

    return RandomFactory;
}();

exports.default = RandomFactory;