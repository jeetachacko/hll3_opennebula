'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/**
 * Factory method for creation random distributed methods
 * Created by Alexey S. Kiselev
 */

var _interfaces = require('./interfaces');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RandomFactory = function () {
    function RandomFactory(method) {
        var _this = this;

        _classCallCheck(this, RandomFactory);

        var Method = require(__dirname + '/methods/' + method);

        for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
        }

        this._method = new (Function.prototype.bind.apply(Method, [null].concat(_toConsumableArray(params))))();
        /**
         * Add methods to this Factory class form the "Method" class
         * Add only that methods which is not in RandomFactory class
         * Because in this class we are re-define existing methods from "Method" class
         * All names of created methods will be the same as in the "Method" class
         */
        Object.getOwnPropertyNames(Object.getPrototypeOf(this._method)).map(function (method) {
            if (!_this.hasOwnProperty(method)) {
                Object.defineProperty(_this, method, {
                    __proto__: null,
                    get: function get() {
                        return _this._method[method];
                    }
                });
            }
        });
    }

    /**
     * Required method
     * Method .random(): Promise<number> generates a random number due to distribution
     * This method is asynchronous, contains method .then(data: number => {}) and
     * .catch(err: {error: string} => {}) corresponds to error in random distribution
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns a random number on each call, can be integer or float
     */


    _createClass(RandomFactory, [{
        key: 'random',
        value: function random() {
            var _this2 = this;

            return new Promise(function (resolve, reject) {
                if (_this2.isError().error) {
                    reject(_this2.isError());
                } else {
                    resolve(_this2._method.random());
                }
            });
        }

        /**
         * Required method
         * Method .randomSync(): number generates a random number due to distribution
         * This method is synchronous
         * Produces a random number or throw an error message
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns a random number on each call, can be integer or float
         */

    }, {
        key: 'randomSync',
        value: function randomSync() {
            if (this.isError().error) {
                throw new Error(this.isError().error);
            } else return this._method.random();
        }

        /**
         * Required method
         * Method .distribution(n: number): Promise<Array<number>> generates an array of random numbers due to distribution
         * Contains n (n > 0) random distributed numbers. By default n = 10
         * Can contains additional parameters for formatting purposes
         * This method is asynchronous, contains method .then(data: Array<number> => {}) and
         * .catch(err: {error: string} => {}) corresponds to error in random distribution
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns an array of random numbers on each call, numbers can be integer or float
         */

    }, {
        key: 'distribution',
        value: function distribution() {
            var _this3 = this;

            for (var _len2 = arguments.length, distParams = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                distParams[_key2 - 1] = arguments[_key2];
            }

            var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

            if (n < 1) {
                n = 1;
            }
            return new Promise(function (resolve, reject) {
                if (_this3.isError().error) {
                    reject(_this3.isError());
                } else {
                    var _method;

                    resolve((_method = _this3._method).distribution.apply(_method, [n].concat(_toConsumableArray(distParams))));
                }
            });
        }

        /**
         * Required method
         * Method .distributionSync(n: number): Array<number> generates an array of random numbers due to distribution
         * Contains n (n > 0) random distributed numbers. By default n = 10
         * Can contains additional parameters for formatting purposes
         * This method is synchronous. Produces an array of random numbers or throw an error message
         * Error can occurs with incorrect input values, served by .isError() method
         * @returns an array of random numbers on each call, numbers can be integer or float
         */

    }, {
        key: 'distributionSync',
        value: function distributionSync() {
            var _method2;

            var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

            if (n < 1) {
                n = 1;
            }

            for (var _len3 = arguments.length, distParams = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                distParams[_key3 - 1] = arguments[_key3];
            }

            if (this.isError().error) {
                throw new Error(this.isError().error);
            } else return (_method2 = this._method).distribution.apply(_method2, [n].concat(_toConsumableArray(distParams)));
        }

        /**
         * Required method
         * Method .isError(): boolean | {error: string} checks whether an error occurs in random method due to incorrect input values
         * This method is synchronous.
         * @returns "false" if no error occurred
         * or {error: string} object with error message if error occurred
         */

    }, {
        key: 'isError',
        value: function isError() {
            return this._method.isError();
        }

        /**
         * Required method
         * Method .refresh(..params): void change th input values in existing distribution without creating new instance
         * Input parameters must be the same as in constructor
         * In this method .isError will refreshes too
         * Examle usage:
         * let normal = randomjs.normal(1, 2);
         * normal.random() // will generate random numbers with Gaussian distribution with mu = 1 and sigma = 2
         * normal.refresh(3, 4);
         * normal.random() // will generate random numbers with Gaussian distribution with mu = 3 and sigma = 4
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            var _method3;

            (_method3 = this._method).refresh.apply(_method3, arguments);
        }

        /**
         * class .toString() method, which will output information about distribution
         * @returns string
         */

    }, {
        key: 'toString',
        value: function toString() {
            return this._method.toString();
        }
    }]);

    return RandomFactory;
}();

exports.default = RandomFactory;