'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _interfaces = require('./interfaces');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/**
 * Random distribution analyzer
 * Long processes in constructor, short processes in methods and properties
 * Also uses AnalyzerFactory to create methods
 * Created by Alexey S. Kiselev
 */

var AnalyzerFactory =

/**
 * Classic constructor
 * But in this method I am going to assign randomArray property
 * Also I am going to check type of array: if not - throw Error
 * @param randomArray<number> - input array
 * @param options - options for analyzer methods
 * @returns {Proxy}
 */


/**
 * Promise array for imported classes
 * @private
 */


/**
 * Main object with public methods
 */
function AnalyzerFactory(randomArray, options) {
    var _this = this;

    _classCallCheck(this, AnalyzerFactory);

    this.randomArray = randomArray;
    this.publicMethods = {};
    this.publicProperties = {};
    this._importedClasses = [];
    this._methodsTypes = {};

    /**
     * Traverse over analyzer folder, get classes from this folder
     * Copy all method (stored in "export" list of the class) to AnalyzerFactory class
     * In this case all logic will be stored in analyzer-folder classes
     * But in AnalyzerFactory class will be only representation
     * Classes constructors will receive only randomArray,
     * For extending functionality uses class inheritance
     * I created Promises for all imported classes, then store these promises to array
     * I need it to achieve asynchronously access to methods
     * Then I evaluate Promise.all to wait all promises
     * !!! Important !!! In this implementation all long processes must be stored in constructor
     * TODO: Implement light version, where all long calculations must be in particular method
     */

    _fs2.default.readdirSync(__dirname + '/analyzer').forEach(function (file) {
        var Methods = require(__dirname + '/analyzer/' + file),
            methodsClass = new Promise(function (resolve, reject) {
            setTimeout(function () {
                /**
                 * If input is not array:
                 * @returns rejected Promise with error
                 */
                if (!Array.isArray(_this.randomArray)) {
                    reject('Input must be an Array!');
                } else if (randomArray.length < 3) {
                    reject('Analyzer.Common: input randomArray is too small, that is no reason to analyze');
                } else {
                    resolve(Methods.getInstance(_this.randomArray, options));
                }
            }, 0);
        });

        // Write properties and function to object for sync checking type of method
        for (var prop in Methods.publicMethods) {
            _this._methodsTypes[prop] = 'property';
        }
        for (var _prop in Methods.publicFunctions) {
            _this._methodsTypes[_prop] = 'function';
        }
        _this._importedClasses.push(methodsClass);
    });

    /**
     * Create an Promise object, which will wait all imported promise classes
     * Then add properties and methods to analyzer
     * Then return a list of public properties and methods object
     */
    var PromiseMethods = Promise.all(this._importedClasses).then(function (methods) {
        /**
         * Add methods to Factory and publicMethods
         */
        methods.forEach(function (methodsClass) {
            // Define Analyzer properties
            if (methodsClass.constructor.publicMethods) {
                Object.keys(methodsClass.constructor.publicMethods).forEach(function (classMethod) {
                    /**
                     * If different classes contain the same public methods
                     * Throw "Methods conflict error"
                     */
                    if (_this.publicMethods[classMethod]) {
                        throw new Error('Analyzer: Methods conflict');
                    }
                    _this.publicMethods[classMethod] = 1;

                    /**
                     * If method is NOT function
                     * Store this method in publicProperties object
                     * I don't need to check methods conflict, because I did it earlier
                     */
                    if (typeof methodsClass[classMethod] !== 'function') {
                        _this.publicProperties[classMethod] = methodsClass[classMethod];
                    }

                    /**
                     * Assign particular properties and methods to Analyzer
                     */
                    Object.defineProperty(_this, classMethod, {
                        __proto__: null,
                        get: function get() {
                            if (typeof methodsClass[classMethod] === 'function') {
                                return function () {
                                    return methodsClass[classMethod].bind(methodsClass).apply(undefined, arguments);
                                };
                            }
                            return _this.publicProperties[classMethod];
                        }
                    });
                });
            }
            // Define Analyzer functions
            if (methodsClass.constructor.publicFunctions) {
                Object.keys(methodsClass.constructor.publicFunctions).forEach(function (classFunction) {
                    /**
                     * If different classes contain the same public methods
                     * Throw "Methods conflict error"
                     */
                    if (_this.publicMethods[classFunction]) {
                        throw new Error('Analyzer: Methods conflict');
                    }

                    /**
                     * If method is function
                     * Store this method in publicProperties object
                     * I don't need to check methods conflict, because I did it earlier
                     */
                    if (typeof methodsClass[classFunction] === 'function') {
                        _this.publicProperties[classFunction] = methodsClass[classFunction].bind(methodsClass);
                    }

                    /**
                     * Assign particular functions to Analyzer
                     */
                    Object.defineProperty(_this, classFunction, {
                        __proto__: null,
                        value: function value() {
                            return methodsClass[classFunction].bind(methodsClass).apply(undefined, arguments);
                        }
                    });
                });
            }
        });
        return _this.publicProperties;
    }).catch(function (err) {
        return Promise.reject(err);
    });

    /**
     * I return Proxy, because I need to return object contains all calculated values
     * For this purpose create Proxy. If I call method - return method
     * Else (where I call class as a function) - return object with all calculated values
     * TODO: check this implementation in browser
     */
    return new Proxy(PromiseMethods, {
        get: function get(obj, method) {
            /**
             * If method is in class methods:
             * Excluding functions
             * @returns: resolved Promise with evaluated method
             */
            if (method === 'then') {
                return function (cb) {
                    return obj.then(function (res) {
                        var result = {};
                        for (var m in res) {
                            if (typeof res[m] !== 'function') {
                                result[m] = res[m];
                            }
                        }
                        return cb.call(obj, result);
                    });
                };
            } else if (method === 'catch') {
                return PromiseMethods.catch.bind(obj);
            } else if (typeof method !== 'string') {
                /**
                 * If we call class as a function (randomjs.analyze(<random_array>)):
                 * @returns resolved Promise with object contains all methods
                 */
                return PromiseMethods.then(function (res) {
                    return res;
                });
            } else if (method in _this._methodsTypes) {
                if (_this._methodsTypes[method] === 'function') {
                    return function () {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        return obj.then(function (res) {
                            return Promise.resolve(res[method].apply(res, args));
                        });
                    };
                } else {
                    return obj.then(function (res) {
                        return Promise.resolve(res[method]);
                    });
                }
            } else {
                return Promise.reject('No such method in Analyzer');
            }
        }
    });
}

/**
 * Object for sync access to analyzer's properties and functions
 * @private
 */


/**
 * Main object with public properties
 */

/**
 * Main randomArray variable to work with
 * All methods will access this variable
 */
;

exports.default = AnalyzerFactory;