'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _shuffle = require('./shuffle');

var _shuffle2 = _interopRequireDefault(_shuffle);

var _prngProxy = require('../prng/prngProxy');

var _prngProxy2 = _interopRequireDefault(_prngProxy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
/**
 * Sample method
 * Get k random elements from array with N elements (0 < k <= N)
 * Created by Alexey S. Kiselev
 */

var Sample = function (_ArrayManipulation) {
    _inherits(Sample, _ArrayManipulation);

    function Sample() {
        _classCallCheck(this, Sample);

        var _this = _possibleConstructorReturn(this, (Sample.__proto__ || Object.getPrototypeOf(Sample)).call(this));

        _this._shuffle = new _shuffle2.default();
        return _this;
    }

    _createClass(Sample, [{
        key: 'getSample',
        value: function getSample(input, k) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { shuffle: false };

            var result = void 0;
            this._validateInput(input);

            // if k is undefined - returns a sample with random size (including [])
            if (typeof k === 'undefined') {
                if (typeof input === 'string') {
                    result = this._getSampleRandomSizeForString(input);
                } else if (Array.isArray(input)) {
                    result = this._getSampleRandomSizeForArray(input);
                } else {
                    result = this._getSampleRandomSizeForObject(input);
                }
                if (options.shuffle && !((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && !Array.isArray(input))) {
                    return this._shuffle.getPermutation(result);
                }
                return result;
            }

            if (typeof k !== 'number' || k <= 0) {
                throw new Error('Sample: "k" must be positive integer');
            }

            if (k >= input.length) {
                if (options.shuffle && !((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && !Array.isArray(input))) {
                    return this._shuffle.getPermutation(input);
                }
                return input;
            }

            // For performance purposes I am going to separate sampling methods for different types
            if (typeof input === 'string') {
                if (k / input.length <= 0.2) {
                    result = this._getHijenhuisWilfSampleForString(input, k);
                } else {
                    result = this._getSampleForString(input, k);
                }
            } else if (Array.isArray(input)) {
                if (k / input.length <= 0.125) {
                    result = this._getHijenhuisWilfSampleForArray(input, k);
                } else {
                    result = this._getSampleForArray(input, k);
                }
            } else {
                result = this._getSampleForObject(input, k);
            }
            if (options.shuffle && !((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && !Array.isArray(input))) {
                return this._shuffle.getPermutation(result);
            }
            return result;
        }

        /**
         * Random sample with random size (including [])
         * @param inputArr: Array
         * @returns {RandomArrayNumberString<number|string>}
         * @private
         */

    }, {
        key: '_getSampleRandomSizeForArray',
        value: function _getSampleRandomSizeForArray(inputArr) {
            var temp = void 0,
                j = 0,
                result = [];
            _prngProxy2.default.random();
            for (var i = 0; i < inputArr.length; i += 1) {
                temp = Math.floor(2 * _prngProxy2.default.next());
                if (temp === 1) {
                    result[j] = inputArr[i];
                    j += 1;
                }
            }
            return result;
        }

        /**
         * Random sample with random size (including '')
         * @param inputArr: string
         * @returns string
         * @private
         */

    }, {
        key: '_getSampleRandomSizeForString',
        value: function _getSampleRandomSizeForString(inputStr) {
            var temp = void 0,
                result = '';
            _prngProxy2.default.random();
            for (var i = 0; i < inputStr.length; i += 1) {
                temp = Math.floor(2 * _prngProxy2.default.next());
                if (temp === 1) {
                    result += inputStr[i];
                }
            }
            return result;
        }

        /**
         * Private getSample method for objects
         * O(k) in memory, O(n) in time
         * @param input: RandomArrayNumberString<number | string>
         * @param k: number
         * @private
         */

    }, {
        key: '_getSampleRandomSizeForObject',
        value: function _getSampleRandomSizeForObject(input) {
            var result = {},
                keys = Object.keys(input),
                temp = void 0;
            _prngProxy2.default.random();
            for (var i = 0; i < keys.length; i += 1) {
                temp = Math.floor(2 * _prngProxy2.default.next());
                if (temp === 1) {
                    result[keys[i]] += input[keys[i]];
                }
            }
            return result;
        }

        /**
         * Improved sampling with O(n + k) in memory and O(k) in time
         * It makes sense only for shuffled results
         * By statistics - it is faster then _getSampleForArray method only for k <= n / 2
         * @param inputArr: Array
         * @param k: number
         * @returns {RandomArrayNumberString<number|string>}
         * @private
         */

    }, {
        key: '_getSampleImprovedForArray',
        value: function _getSampleImprovedForArray(inputArr, k) {
            var input = inputArr.slice(),
                n = input.length,
                ni = n,
                r = -1,
                result = [],
                m = 0; // elements in result
            _prngProxy2.default.random();
            while (m < k) {
                r = Math.floor(_prngProxy2.default.next() * ni);
                result[m] = [r, input[r]];
                m += 1;
                // swap chosen element and last element
                ni -= 1;
                // $FlowFixMe - Destructuring swap is faster
                var _ref = [input[ni], input[r]];
                input[r] = _ref[0];
                input[ni] = _ref[1];
            }
            return result;
        }

        /**
         * Hijenhuis & Wilf algorithm for indexes
         * Improved sampling with O(k) time complexity
         * Does not mutate original array
         * @param n: number - number of elements in array or string
         * @param k: number
         * @returns {RandomArray} - array with random indexes shifted by one to the right
         * @private
         */

    }, {
        key: '_getHijenhuisWilfSampleIndexes',
        value: function _getHijenhuisWilfSampleIndexes(n, k) {
            var c = void 0,
                a = [],
                x = void 0,
                l = void 0,
                i = void 0,
                p = void 0,
                s = void 0,
                temp = void 0,
                delta_s = void 0,
                r = void 0,
                m0 = void 0,
                m = void 0;

            _prngProxy2.default.random();

            // 1 - O(k) complexity
            for (var idx = 0; idx < k; idx += 1) {
                a[idx] = Math.floor(idx * n / k);
            }
            c = k;

            // 2
            while (c > 0) {
                x = 1 + Math.floor(_prngProxy2.default.next() * n);
                l = 1 + Math.floor((x * k - 1) / n);
                if (x > a[l - 1]) {
                    a[l - 1] += 1;
                    c -= 1;
                }
            }
            i = 0;
            p = 0;
            s = k;

            // 3 - O(k) complexity
            while (i < k) {
                i += 1;
                if (a[i - 1] === Math.floor(n * (i - 1) / k)) {
                    a[i - 1] = 0;
                    continue;
                }
                p += 1;
                temp = a[i - 1];
                a[i - 1] = 0;
                a[p - 1] = temp;
            }

            // 4
            while (p > 0) {
                l = 1 + Math.floor((a[p - 1] * k - 1) / n);
                delta_s = a[p - 1] - Math.floor((l - 1) * n / k);
                a[p - 1] = 0;
                a[s - 1] = l;
                s -= delta_s;
                p -= 1;
            }
            l = k;

            // 5
            while (l > 0) {
                if (a[l - 1] > 0) {
                    r = l;
                    m0 = 1 + Math.floor((a[l - 1] - 1) * n / k);
                    m = Math.floor(a[l - 1] * n / k) - m0 + 1;
                }
                // $FlowFixMe
                x = m0 + Math.floor(_prngProxy2.default.next() * m);
                i = l;
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    i += 1;
                    // $FlowFixMe
                    if (i > r || x < a[i - 1]) {
                        break;
                    }
                    a[i - 2] = a[i - 1];
                    x += 1;
                }
                a[i - 2] = x;
                // $FlowFixMe
                m -= 1;
                l -= 1;
            }

            return a;
        }

        /**
         * Private getSample method (Hijenhuis & Wilf algorithm) for arrays
         * @param input: RandomArrayNumberString<number | string>
         * @param k: number
         * @private
         */

    }, {
        key: '_getHijenhuisWilfSampleForArray',
        value: function _getHijenhuisWilfSampleForArray(input, k) {
            // for arrays
            var result = [],
                n = input.length,
                indexes = this._getHijenhuisWilfSampleIndexes(n, k);
            for (var idx = 0; idx < k; idx += 1) {
                result[idx] = input[indexes[idx] - 1];
            }
            return result;
        }

        /**
         * Private getSample method (Hijenhuis & Wilf algorithm) for strings
         * @param input: string
         * @param k: number
         * @private
         */

    }, {
        key: '_getHijenhuisWilfSampleForString',
        value: function _getHijenhuisWilfSampleForString(input, k) {
            // for strings
            var result = '',
                n = input.length,
                indexes = this._getHijenhuisWilfSampleIndexes(n, k);
            for (var idx = 0; idx < k; idx += 1) {
                result += input[indexes[idx] - 1];
            }
            return result;
        }

        /**
         * Private getSample method for arrays
         * O(k) in memory and O(n) in time
         * @param input: RandomArrayNumberString<number | string>
         * @param k: number
         * @private
         */

    }, {
        key: '_getSampleForArray',
        value: function _getSampleForArray(input, k) {
            // for arrays
            var result = [],
                n = input.length,
                t = 0,
                // total elements
            m = 0; // selected elements
            _prngProxy2.default.random();
            while (m < k) {
                if ((n - t) * _prngProxy2.default.next() < k - m) {
                    result[m] = input[t];
                    m += 1;
                }
                t += 1;
            }
            return result;
        }

        /**
         * Private getSample method for arrays
         * O(k) in memory, O(n) in time
         * @param input: string
         * @param k: number
         * @private
         */

    }, {
        key: '_getSampleForString',
        value: function _getSampleForString(input, k) {
            // for strings
            var result = '',
                n = input.length,
                t = 0,
                // total elements
            m = 0; // selected elements
            _prngProxy2.default.random();
            while (m < k) {
                if ((n - t) * _prngProxy2.default.next() < k - m) {
                    result += input[t];
                    m += 1;
                }
                t += 1;
            }
            return result;
        }

        /**
         * Private getSample method for objects
         * O(k) in memory, O(n) in time
         * @param input: RandomArrayNumberString<number | string>
         * @param k: number
         * @private
         */

    }, {
        key: '_getSampleForObject',
        value: function _getSampleForObject(input, k) {
            // for objects
            var result = {},
                keys = Object.keys(input),
                n = keys.length,
                t = 0,
                // total elements
            m = 0; // selected elements
            _prngProxy2.default.random();
            while (m < k) {
                if ((n - t) * _prngProxy2.default.next() < k - m) {
                    result[keys[t]] = input[keys[t]];
                    m += 1;
                }
                t += 1;
            }
            return result;
        }
    }]);

    return Sample;
}(_base2.default);

exports.default = Sample;