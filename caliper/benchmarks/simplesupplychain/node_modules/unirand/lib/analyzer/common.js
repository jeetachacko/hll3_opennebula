'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _desc, _value, _class2;

var _decorators = require('../decorators');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Common analyzer's methods
 * This class contains max, min, mean, median, mode, entropy, variance ... methods
 * Created by Alexey S. Kiselev
 */

var Common = (0, _decorators.AnalyzerSingleton)(_class = (_class2 = function () {

  /**
   * Entropy
   * @private
   */


  /**
   * CDF object contains CDF function values
   * @private
   */


  /**
   * Number of values in PDF and CDF functions
   * @private
   */


  /**
   * Skewness value
   * @private
   */


  /**
   * Mean value
   * @private
   */


  /**
   * Maximum number in array
   * For some distributions can be really big (much bigger then mean)
   * @private
   */
  function Common(randomArray, options) {
    _classCallCheck(this, Common);

    /**
     * Check if randomArray is array
     * if not - throw Error
     * @type {Array.<number>}
     */
    if (!Array.isArray(randomArray)) {
      throw new Error('Analyzer.Common: input randomArray must be an array');
    }

    /**
     * Check if array is too small
     */
    if (randomArray.length < 3) {
      throw new Error('Analyzer.Common: input randomArray is too small, that is no reason to analyze');
    }

    /**
     * Create inner variables
     */
    this.randomArray = randomArray;
    this._maximum = -Infinity;
    this._minimum = Infinity;
    this._values_in_pdf = 200;
    if (options && Number(options.pdf)) {
      this._values_in_pdf = Number(options.pdf);
    }
    this._entropy = 0;
    this._modes = [];

    /**
     * I am going to run calculateParams for calculate all parameters
     * I need it for performance, because I want to traverse array only once
     */
    this._calculateParams();
  }

  /**
   * Main methods for calculating random array parameters
   * I will traverse over array only once with O(n) time
   * During iteration I will calculate necessary parameters
   * Also I add some additional variables to calculate params
   * This method will not return nothing, but will calculate special properties
   * Then I will transfer this value to AnalyzerFactory via AnalyzerPublicMethod decorator
   * @private
   */


  /**
   * Modes array
   * @private
   */


  /**
   * PDF Values object contains PDF function x-values
   * @private
   */


  /**
   * PDF object contains PDF function values
   * @private
   */


  /**
   * Kurtosis value
   * @private
   */


  /**
   * Variance
   * @private
   */


  /**
   * Minimum number in array
   * For some distributions can be really small (much smaller then mean)
   * @private
   */

  /**
   * Main input Array
   */


  _createClass(Common, [{
    key: '_calculateParams',
    value: function _calculateParams() {
      /**
       * For mean value M and variance M2 I am going to use Knuth's algorithm
       * So, create M and M2 variables with initial zeros
       * Also I create a counter n for calculating values and additional variable delta
       */
      var M = 0,
          M2 = 0,
          M3 = 0,
          M4 = 0,
          n = 0,
          delta = void 0,
          delta_n = void 0,
          delta_n2 = void 0,
          term1 = void 0,
          correction = 100; // correction needs to calculate floats with better accuracy

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.randomArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var rv = _step.value;

          // Calculating max and min values
          if (rv > this._maximum) {
            this._maximum = rv;
          }

          if (rv < this._minimum) {
            this._minimum = rv;
          }

          // Calculating moments
          n += 1;
          delta = rv * correction - M;
          delta_n = delta / n;
          delta_n2 = Math.pow(delta_n, 2);
          term1 = delta * delta_n2 * (n - 1);
          M += delta_n;
          M4 += term1 * delta_n * (n * n - 3 * n + 3) + 6 * delta_n2 * M2 - 4 * delta_n * M3;
          M3 += (n - 2) * term1 - 3 * delta_n * M2;
          M2 += delta * (rv * correction - M);
        }

        // Assign mean, variance, skewness and kurtosis values
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._mean = M / correction;
      this._variance = M2 / ((n - 1) * Math.pow(correction, 2));
      this._skewness = Math.sqrt(n) * M3 / Math.pow(M2, 1.5);
      this._kurtosis = n * M4 / (M2 * M2);

      /**
       * Calculating PDF and CDF
       * I am going to cut the range to <_values_in_pdf> values, then calculate range hit of random value
       * Then store this results to Analyzer public method "pdf"
       * Also I am going to use this results to calculate other parameters like entropy
       * If the size of input array is less then <_values_in_pdf> - use dynamic range length
       */
      var rvLength = this.randomArray.length,
          values_in_pdf = rvLength < this._values_in_pdf ? rvLength : this._values_in_pdf,
          pdf = new Array(values_in_pdf),
          cdf = new Array(values_in_pdf),
          pdf_values = new Array(values_in_pdf),
          values_step = this._maximum === this._minimum ? 1 : (this._maximum - this._minimum) / (values_in_pdf - 1),
          tempIndex = void 0;

      // Create PDF and CDF arrays with initial zeros
      pdf.fill(0);

      // Iterate over randomArray and add value to pdf
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.randomArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _rv = _step2.value;

          tempIndex = Math.floor((_rv - this._minimum) / values_step);
          pdf[tempIndex] += 1;
        }

        // Cumulative variable for CDF
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var sumOfPDF = 0;

      /**
       * Calculate mode value
       * max_pdf - maximum value of pdf
       * max_mode - value of max_pds
       * I am going to compare value with delta = 0.1% due to accuracy
       */
      var max_pdf = pdf[0] / rvLength;

      /**
       * Calculate cumulative step for entropy for collect step for pdf equals to zero
       * Iterate over PDF to find first non zero value (except with index 0)
       * I need it to calculate correct entropy for index 0
       */
      var cumulative_step = values_step;
      for (var i = 1; i < pdf.length; i += 1) {
        if (pdf[i] !== 0) break;
        cumulative_step += values_step;
      }

      // Convert pdf to probability
      for (var _i = 0; _i < pdf.length; _i += 1) {
        pdf[_i] /= rvLength;
        pdf_values[_i] = this._minimum + _i * values_step;

        // Calculate CDF
        sumOfPDF += pdf[_i];
        cdf[_i] = sumOfPDF;

        // Calculate mode
        if (pdf[_i] - max_pdf > 0.005 * pdf[_i]) {
          max_pdf = pdf[_i];
          this._modes = [pdf_values[_i]];
        } else if (pdf[_i] - max_pdf > -0.005 * pdf[_i]) {
          this._modes.push(pdf_values[_i]);
        }

        // Calculate entropy
        cumulative_step += values_step;
        if (pdf[_i] !== 0 && pdf[_i] !== 1) {
          this._entropy -= cumulative_step === 0 ? 0 : pdf[_i] * Math.log(pdf[_i] / cumulative_step);
          cumulative_step = 0;
        }
      }

      this._pdf = pdf;
      this._pdf_values = pdf_values;
      this._cdf = cdf;
    }

    /**
     * Public method for AnalyzerFactory
     * @returns {number} - minimum value in array
     */

  }, {
    key: 'min',
    get: function get() {
      return this._minimum;
    }

    /**
     * Public method for AnalyzerFactory
     * @returns {number} - maximum value in array
     */

  }, {
    key: 'max',
    get: function get() {
      return this._maximum;
    }

    /**
     * Public method for Analyzer
     * @returns {number} - mean value of random array
     */

  }, {
    key: 'mean',
    get: function get() {
      return this._mean;
    }

    /**
     * Public method for Analyzer
     * @returns {number} - mode value for random distribution
     */

  }, {
    key: 'mode',
    get: function get() {
      return this._modes;
    }

    /**
     * Public method for Analyzer
     * @returns {number} - variance of random array
     */

  }, {
    key: 'variance',
    get: function get() {
      return this._variance;
    }

    /**
     * Public method for Analyzer
     * @returns {number} - standard deviation
     */

  }, {
    key: 'standard_deviation',
    get: function get() {
      return Math.sqrt(this._variance);
    }

    /**
     * Public method for Analyzer
     * @returns {number} - Entropy of random distribution
     */

  }, {
    key: 'entropy',
    get: function get() {
      return this._entropy;
    }

    /**
     * Public method for Analyzer
     * @returns {number} - Skewness of random distribution
     */

  }, {
    key: 'skewness',
    get: function get() {
      return this._skewness;
    }

    /**
     * Public method for Analyzer
     * @returns {number} - Kurtosis value of random distribution
     */

  }, {
    key: 'kurtosis',
    get: function get() {
      return this._kurtosis;
    }

    /**
     * Public method for Analyzer
     * @returns {AnalyzerPDF} - object with PDF function and its values
     */

  }, {
    key: 'pdf',
    get: function get() {
      return {
        values: this._pdf_values,
        probabilities: this._pdf
      };
    }

    /**
     * Public method for Analyzer
     * @returns {AnalyzerPDF} - object with CDF function and its values
     */

  }, {
    key: 'cdf',
    get: function get() {
      return {
        values: this._pdf_values,
        probabilities: this._cdf
      };
    }
  }]);

  return Common;
}(), (_applyDecoratedDescriptor(_class2.prototype, 'min', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'min'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'max', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'max'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'mean', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'mean'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'mode', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'mode'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'variance', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'variance'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'standard_deviation', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'standard_deviation'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'entropy', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'entropy'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'skewness', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'skewness'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'kurtosis', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'kurtosis'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'pdf', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'pdf'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'cdf', [_decorators.AnalyzerPublicMethod], Object.getOwnPropertyDescriptor(_class2.prototype, 'cdf'), _class2.prototype)), _class2)) || _class;

module.exports = Common;